+++
title = "Obelisk Consensus Algorithm Design Motivations"
tags = [
    "Obelisk",
    "Consensus",
    "Skywire",
]
date = "2017-10-26"
categories = [
    "Statement",
]
bounty = 40
+++

*これは2014年6月19日のBitcointalksスレッドからアーカイブされた投稿です。*

>引用：2014年6月19日のyxxyun、、02:52:38 AM

>>引用：2014年6月19日のSkycoin、02:31:59 AM

>>>引用：2014年6月18日のFrictionlessCoin、09:15:07 PM

>>>>2014年6月18日のSkycoin、09:08:56 PM

>>>>開発アップデート：

>>>>我々はハイブリッドなProof of Stake (PoS)のシステムを用いたシビルアタックを、防ぐ方法を考えだしました。

>>>>ノードを作成するには、コインを持っていることを証明しなければいけません。
>>>>10コイン持っていることを宣言し、Aのアドレスに10コインを送金します。
>>>>その後、BのアドレスからAのアドレスに10コインが送金されます。
>>>>そして、自身のObeliskブロックチェーンにメッセージを書き込むためにAのアドレスの公開鍵を使用して署名を追加します。

>>>>または、Aのアドレスの公開鍵を公開し、その鍵を用いてメッセージに署名することもできます。
>>>>ノードは、他のピアとの有効な信頼関係を維持するために、毎度署名を発行するか予備のコインのブロック内でコインを移動させなくてはいけません。

>>>>または、プライベートな鍵を持たないBのアドレスにAのアドレスからコインを送るためには、Proof of Burn (PoB)が求められることがあります。
>>>>完璧なノードを操作するために、最初から全てのブロックチェーンをダウンロードする必要がないという要件と、PoBは相反するでしょうか、そんなことはありません。

>>>>このシステムは、Obeliskノードの数の上限を設定し、Obeliskノードがコイン所有者になる能力を制限しています。
>>>>ノード数の上限とコインの必要要件を定めることで、シビルアタックを守る別の層を追加することができます。

>>>これがどうやってシビルアタックを防いでいるのかわかりません。
>>>ネットワークにノードを追加してコストが増えるだけで、それと同じようにシビルアタックにもコストが必要とされることなんてありますか？

>>これは、この段階における考えなだけで、今は改善方法を見つけました。
>>それぞれのObeliskノードは公開鍵を所有しています。
>>私達は、公開鍵をアドレスにハッシュし、そしてそのアドレスによって10コインのアウトプットが保存されます。

>>このアイディアは追加のコストを必要としません。
>>ただあなた自身の10コインの所有を証明するだけです。
>>このアイディアによって、プライベートキーを知っていることを証明します。
>>公開鍵によって、誰のアドレスに10コインがあるのかを証明します。

>>このアイデアの特徴は、ノードの数に上限を設けていることです。
>>もし10コインを保持が必要で、1億コインが発行されるのであれば、ネットワークの上限は1000万ノードです。
>>現時点では、この上限は数学的に有効ではないように見えますが、覚えておく必要があります。

>>新しいObeliskノードが実行されると、いくつかのランダムなピアを「信頼」します。
>>ユーザーは、そのオベリスクコードが信頼するいくつかのノード（取引所または信頼できるコミュニティメンバー）を手作業で追加することもできます。
>>ノードは、その公開鍵のハッシュによって識別され、DHTによって発見されます。
>>ノードがIP：ポートのペアであるBitcoinのようなものではないです。
>>コンピュータを移動することができ、ノードの識別はIPアドレスに依存しません。

>>私たちはランダムなノードを選択してネットワークを安全にしたい。
>>3人の開発者ノードがネットワークを制御するRippleのような状況は望みません。
>>しかし、誰かが200,000のノードを実行し、新しいユーザーから信頼関係を集めようとする状況は防ぎたいのです。
>>これらのシビルアタックのノードは、未だ51％攻撃ができませんが、攻撃のコストを増加させるものはまだ使えます。

>>恐らく、新しいユーザーがコインバランスをとるノードをランダムに信頼するように制限するでしょう。
>>ノードにコインのバランスがない場合、信頼関係は切断されませんが、新しいランダム・ユーザーが得られる内容にするでしょう。

>>信頼関係のための連結グラフは、完全に接続されたランダムグラフであると考えられています。
>>いくつかのノード（信頼できるコミュニティーメンバー、取引所、ウェブサイト、組織）はより強い信頼関係を持ち、それはブロックコンセンサスのコンバージェンス時間(更新が終わるまでにかかる時間)を少し助けます。
>>これは、ネットワークのDiameter(ネットワークの認証で使われるプロトコル)を少し減らします。
>>いくつかのノードはコンセンサスを確認するために使用されます（あなたは多数の取引所または異なる公開鍵を選択します）。
>>これらのノードはコンセンサスの決定に影響しませんが、ノードがネットワークに統合されているかどうかを確認する "consensus oracles(同意についての託宣)"です

>>2つの大きな取引所が特定のブロックに対して異なるコンセンサスを持つことは問題になります。
>>ネットスプリットまたはネットワーク上の攻撃を示す可能性があります。
>>取引所は、問題が解決するまで取引を中断するかもしれません。

>ObeliskはSkycoinのコンセンサスノードを配布していますか？
>私はSkycoindがノードだと思っていた...

はい。

Skycoinにはブロックチェーンがあります。
ブロックチェーンは
https://github.com/skycoin/skycoin/tree/develop/src/coin
にあります。
これによりブロックが解析され、未使用の出力とトランザクションが処理されます

Skywireはデーモン(UNIXなどのOSにおいてバックグラウンドプロセスとして動作するプログラム)であり、 "サービスアーキテクチャ"を持っています。
ブロックチェーン同期サービスなどのサービスを実行できます。
メッシュネットは現在、Skywire上のサービスとして実装されています。
（これは変更する必要がありそうです）

コンセンサスメカニズムはブロックチェーンの外にあります。
Obeliskノード（おそらくSkywireサービスとして実装される）にはブロックチェーンがあります。
各ノードには公開鍵があります。
公開鍵はObeliskを識別します。
各オベリスクノードには独自のブロックチェーンがあります（このチェーンにコインはありません）。
ノードは新しいブロックを作成し、それを秘密鍵で署名します。
オベリスクブロックチェーンは、コンセンサス（Skycoinブロックチェーンのヘッドブロックの決定）を交渉するために使用されます。
ObeliskはBen-Orをランダムなコンセンサスに使用しています。
各Obeliskノードには、加入している他のノードのリストがあります。
これらのノードは、ローカルノードのコンセンサスおよび投票の決定に影響します。
非病理学的なネットワークトポロジーでは、ローカルなコンセンサスがグローバルコンセンサスに収束することが明らかです。

　各ノードはチェーン内の次のブロックに投票します。
ノードは次のブロックを提案し、ノードは後継ノードに投票する。
投票は、各ノードのObeliskブロックチェーンのブロックに公開されます。
あなたのノードは代替案の間で無作為に投票し、しばらくの間、その投票を一回フリップします。peersの40％（あなたが署名しているノード）がコンセンサスに達したら、その候補に切り替えます。
ネットワークは一度に複数のフォークに投票することができますが、コンセンサスを待つためにより長く時間をかけるということはしません。
フォークは、時間の経過と共に単一のチェーンに枝刈りされます。
2つまたは3つのブロックの分割は正常ですが、いくつかの確認の後、ブロックが復帰する確率は急激にゼロに減少します。
トランザクションがすべての候補のチェーンで実行された場合、特定のコンセンサスチェーンがまだ決定されていなくても、実行されます。

　これはバイナリのBen-OrとSkycoinがコンセンサスセットから複数の後継ブロックが選択されている場合に、より高速なものを使用します。
ランダム化は、ネットワークのサブグラフが詰まるのを防ぐために重要です。
投票プロセスは、各ノードがローカル情報からのみグローバルコンセンサスに独立して到着する「アニーリング」の一形態です。

　コンセンサスプロセスは公開して行われます。
ノードはブロックを公開し、プライベートキーで署名し、ブロックはチェーンのサブスクライバ間でP2Pに複製されます。
次に、コンセンサスを検証するために使用されるがコンセンサスに影響を与えないノードである “consensus oracles”が存在します。
だから、あなたはいくつかの取引所の公開鍵といくつかの信頼できるコミュニティーメンバーを選んで、あなたのノードが間違っているかどうかを検出するためにそれらを使用します。
これは、ネットスプリットを検出するために使用されます。
また、ハッカーがルーターを制御し、接続可能なピアを制御できる攻撃から保護します。

　ノードがネットワークに現れ、51％攻撃やトランザクションを元に戻すなどの行動を違うチェーンに仕掛けると、通常は無視されます。
ほとんどの51％攻撃は、自動的に検出された悪性ノードの動作を必要とし、署名したノードが悪意のあるノードを信頼リストから除去する結果となります。
最も簡単な51％攻撃の方法は、簡単に検出でき、トランザクションを元に戻す試みとして意図されていることを数学的に確実に証明できます。
なぜなら、51%攻撃はブロックコンセンサスの決定をバックデートする必要があるからです。
同じシーケンス番号を持つ2つの署名されたブロックを公開する必要があるため、ノードに対して自動で禁止することができました。

　私たちは、ノードのサブネットワークがオフラインになって（netsplit攻撃）、別のブロックチェーンコンセンサスでネットワークに再び参加し、ネットワーク上でトランザクションを元に戻すように強制しようとする、51％攻撃の最後の可能性を排除しようとしています。
サブネットワークに十分な影響がないため、これらの攻撃のほとんどは失敗します。

　この攻撃を解決することはまだ難しいです。
成功した51％攻撃がある場合、1つの解決策は、ネットワークをフリーズさせて、各ノード/ユーザがどのチェーンが有効なものかを個別に選択させ、攻撃するノードを手動で禁止することです。consensus oracleは、各ノードが、状態が同期されているかどうか、またグローバルコンセンサスに達しているかどうか、またはそれらがnetsplitサブグラフの一部であるかどうかを知ることを高い確率で可能にします。
ノードがコンセンサス決定の間にオフラインであったかどうかを、ローカル情報から高い正確性で知ることが可能であると考え、突然現れるオフラインのノードを無視し、ネットワーク上でチェーンフォークを強制しようとします。

Bitcoinでは、あなたが最もハッシュ力を持っているなら、いつでもトランザクションを元に戻すことができます。

Skycoinでは、取引を元に戻すためには：

- 多くのノードを制御する
- 管理するノードは、ネットワークトポロジ内で影響力があり、信頼できるものでなければならない
- ネットワークを攻撃するために必要な信頼関係が失われてしまうため、ノードは動作が検出されずに非常に露骨で病的な攻撃の動作をする必要がある
-あなたのノードは、検出されずに病的な攻撃のトポロジーに入る必要がある（ほとんどのボットノードは少数の人間によって信頼され、非常にわかりやすい）
- 攻撃を成功させる方法は、あなたがコントロールし結託をするためのノードを得ることができなければならない（これはあまり簡単ではない）
- 攻撃が成功した場合、手動でネットワークが攻撃を元に戻さないようにする必要がある（攻撃のためにコインや金銭を紛失した場合は非常に困難）

それが51％の攻撃証明であることを証明するには、作成している仮定を書き留めてから、簡単な数学的モデルを作成し、そのモデルで起こりうることを証明する必要があります。
攻撃が可能な条件を知ったら、その攻撃の排除を試みます。もしそれらを除去できなければ、可能な限り攻撃を難しくします。
攻撃コストを増加させると、特定の攻撃が成功する可能性が低くなります。
次に、攻撃に対する報酬とインセンティブを減らします。

コンセンサスプロセスはシンプルで簡単にモデル化できますが、直感的ではありません。アニメーション化されたコンセンサスプロセスを持つjavascriptサイトがあります。
